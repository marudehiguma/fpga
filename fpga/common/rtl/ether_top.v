
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================


module ether_top(

	//////////// CLOCK //////////
	input 		          		CLOCK_50,
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,

	//////////// LED //////////
	output		     [8:0]		LEDG,
	output		    [17:0]		LEDR,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		    [17:0]		SW,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,
	output		     [6:0]		HEX6,
	output		     [6:0]		HEX7,

	//////////// LCD //////////
	output		          		LCD_BLON,
	inout 		     [7:0]		LCD_DATA,
	output		          		LCD_EN,
	output		          		LCD_ON,
	output		          		LCD_RS,
	output		          		LCD_RW,

	//////////// RS232 //////////
	input 		          		UART_CTS,
	output		          		UART_RTS,
	input 		          		UART_RXD,
	output		          		UART_TXD,

	//////////// SDCARD //////////
	output		          		SD_CLK,
	inout 		          		SD_CMD,
	inout 		     [3:0]		SD_DAT,
	input 		          		SD_WP_N,

	//////////// VGA //////////
	output		     [7:0]		VGA_B,
	output		          		VGA_BLANK_N,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// Ethernet 0 //////////
	output		          		ENET0_GTX_CLK,
	input 		          		ENET0_INT_N,
	input 		          		ENET0_LINK100,
	output		          		ENET0_MDC,
	inout 		          		ENET0_MDIO,
	output		          		ENET0_RST_N,
	input 		          		ENET0_RX_CLK,
	input 		          		ENET0_RX_COL,
	input 		          		ENET0_RX_CRS,
	input 		     [3:0]		ENET0_RX_DATA,
	input 		          		ENET0_RX_DV,
	input 		          		ENET0_RX_ER,
	input 		          		ENET0_TX_CLK,
	output		     [3:0]		ENET0_TX_DATA,
	output		          		ENET0_TX_EN,
	output		          		ENET0_TX_ER,
	input 		          		ENETCLK_25,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [31:0]		DRAM_DQ,
	output		     [3:0]		DRAM_DQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_WE_N,

	//////////// SRAM //////////
	output		    [19:0]		SRAM_ADDR,
	output		          		SRAM_CE_N,
	inout 		    [15:0]		SRAM_DQ,
	output		          		SRAM_LB_N,
	output		          		SRAM_OE_N,
	output		          		SRAM_UB_N,
	output		          		SRAM_WE_N,

        input                                   SPIM_MISO ,
        output                                  SPIM_MOSI ,
        output                                  SPIM_SS_N ,
        output                                  SPIM_SCLK ,

	//////////// GPIO, GPIO connect to LT24 - 2.4" LCD and Touch //////////
	input 		          		LT24_ADC_BUSY,
	output		          		LT24_ADC_CS_N,
	output		          		LT24_ADC_DCLK,
	output		          		LT24_ADC_DIN,
	input 		          		LT24_ADC_DOUT,
	input 		          		LT24_ADC_PENIRQ_N,
	output		          		LT24_CS_N,
	output		    [15:0]		LT24_D,
	output		          		LT24_LCD_ON,
	output		          		LT24_RD_N,
	output		          		LT24_RESET_N,
	output		          		LT24_RS,
	output		          		LT24_WR_N
);
  `include "./mico32_vga_define.v"

  // 2018.1.6
  // Active = Low
  //       [0]
  //     --------
  // [5]|        |[1]
  //    |  [6]   |
  //     --------
  // [4]|        |[2]
  //    |        |
  //     --------
  //       [3]

  parameter SEG7_0   = 7'b1000000;
  parameter SEG7_1   = 7'b1111001;
  parameter SEG7_2   = 7'b0100100;
  parameter SEG7_3   = 7'b0110000;
  parameter SEG7_4   = 7'b0011001;
  parameter SEG7_5   = 7'b0010010;
  parameter SEG7_6   = 7'b0000010;
  parameter SEG7_7   = 7'b1111000;
  parameter SEG7_8   = 7'b0000000;
  parameter SEG7_9   = 7'b0010000;
  parameter SEG7_A   = 7'b0001000;
  parameter SEG7_B   = 7'b0000011;
  parameter SEG7_C   = 7'b1000110;
  parameter SEG7_D   = 7'b0100001;
  parameter SEG7_E   = 7'b0000110;
  parameter SEG7_F   = 7'b0001110;
  parameter SEG7_OFF = 7'b1111111;

  reg   [6:0]   HEX0_REG;
  reg   [6:0]   HEX1_REG;
  reg   [6:0]   HEX2_REG;
  reg   [6:0]   HEX3_REG;
  reg   [6:0]   HEX4_REG;
  reg   [6:0]   HEX5_REG;
  reg   [6:0]   HEX6_REG;
  reg   [6:0]   HEX7_REG;

//==================_0=====================================
//  REG/WIRE declara_Otions
//=======================================================

//	wire		     [22:0]		LEDG_dummy;
	wire		     [23:0]		LEDG_dummy;

  wire           load_store_unit_ram_out_and;
  wire           reset = KEY[0];

  wire   [31:0]  EXT1_DAT_I_bf_en;
  wire   [31:0]  EXT1_DAT_O      ;
  wire   [31:0]  LM32D_ADR_O     ;
  wire   [ 3:0]  LM32D_SEL_O     ;
  wire   [ 1:0]  LM32D_BTE_O     ;

//=======================================================
//  Structural coding
//=======================================================

  // WB to AXI  ------------------------------------------------------
  wbm2axisp wbm2axisp1 (
    .i_clk         ( CLOCK_50         )
  , .i_reset       ( reset            )
  , .i_wb_cyc      ( LM32D_CYC_O      )
  , .i_wb_stb      ( LM32D_STB_O      )
  , .i_wb_we       ( LM32D_WE_O       )
  , .i_wb_addr     ( LM32D_ADR_O[31:6])
  , .i_wb_data     ( EXT1_DAT_O       )
  , .i_wb_sel      ( LM32D_SEL_O      )
  , .o_wb_ack      ( EXT1_ACK_I       )
  , .o_wb_stall    (                  )
  , .o_wb_data     ( EXT1_DAT_I_bf_en )
  , .o_wb_err      ( EXT1_ERR_I       )
  // AXI write address channel signals
  , .i_axi_awready (                  ) // Slave is ready to accept
  , .o_axi_awid    (                  ) // Write ID
  , .o_axi_awaddr  (                  ) // Write address
  , .o_axi_awlen   (                  ) // Write Burst Length
  , .o_axi_awsize  (                  ) // Write Burst size
  , .o_axi_awburst (                  ) // Write Burst type
  , .o_axi_awlock  (                  ) // Write lock type
  , .o_axi_awcache (                  ) // Write Cache type
  , .o_axi_awprot  (                  ) // Write Protection type
  , .o_axi_awqos   (                  ) // Write Quality of Svc
  , .o_axi_awvalid (                  ) // Write address valid
  // AXI write data channel signals
  , .i_axi_wready  (                  ) // Write data ready
  , .o_axi_wdata   (                  ) // Write data
  , .o_axi_wstrb   (                  ) // Write strobes
  , .o_axi_wlast   (                  ) // Last write transaction   
  , .o_axi_wvalid  (                  ) // Write valid
  // AXI write response channel signals
  , .i_axi_bid     (                  ) // Response ID
  , .i_axi_bresp   (                  ) // Write response
  , .i_axi_bvalid  (                  ) // Write reponse valid
  , .o_axi_bready  (                  ) // Response ready
  // AXI read address channel signals
  , .i_axi_arready (                  ) // Read address ready
  , .o_axi_arid    (                  ) // Read ID
  , .o_axi_araddr  (                  ) // Read address
  , .o_axi_arlen   (                  ) // Read Burst Length
  , .o_axi_arsize  (                  ) // Read Burst size
  , .o_axi_arburst (                  ) // Read Burst type
  , .o_axi_arlock  (                  ) // Read lock type
  , .o_axi_arcache (                  ) // Read Cache type
  , .o_axi_arprot  (                  ) // Read Protection type
  , .o_axi_arqos   (                  ) // Read Protection type
  , .o_axi_arvalid (                  ) // Read address valid
  // AXI read data channel signals   
  , .i_axi_rid     (                  ) // Response ID
  , .i_axi_rresp   (                  ) // Read response
  , .i_axi_rvalid  (                  ) // Read reponse valid
  , .i_axi_rdata   (                  ) // Read data
  , .i_axi_rlast   (                  ) // Read last
  , .o_axi_rready  (                  ) // Read Response ready
  );

  //  ether  ------------------------------------------------------
  del_chat del_chat_reset ( .clk(CLOCK_50), .in(reset), .out(KEY0_del_chat) );

  ether ether1 (
      .clk_i          (CLOCK_50                )
  //, .reset_n        (KEY0_del_chat           )
    , .reset_n        (reset                   )
    , .uartSIN        (UART_RXD                )
    , .uartSOUT       (UART_TXD                )
  //, .gpioPIO_OUT    ({LEDG_dummy, LEDG      })  // dummy=23bit + LEDG=9bit
    , .gpioPIO_OUT    ({LEDG_dummy, LEDG[7:0] })  // dummy=24bit + LEDG=8bit
//  , .gpioPIO_OUT    (                        )
    , .gpio2PIO_OUT   (                        )
    , .spiMISO_MASTER (SPIM_MISO               )
    , .spiMOSI_MASTER (SPIM_MOSI               )
    , .spiSS_N_MASTER (SPIM_SS_N               )
    , .spiSCLK_MASTER (SPIM_SCLK               )
    , .load_store_unit_ram_out_and(load_store_unit_ram_out_and )
  , .VGA_R            (VGA_R                   )
  , .VGA_G            (VGA_G                   )
  , .VGA_B            (VGA_B                   )
  , .VGA_SYNC_N       (VGA_SYNC_N              )
  , .VGA_BLANK_N      (VGA_BLANK_N             )
  , .VGA_CLK          (VGA_CLK                 )
  , .VGA_HS           (VGA_HS                  )
  , .VGA_VS           (VGA_VS                  )
  , .LM32D_ADR_O      (LM32D_ADR_O             )
  , .LM32D_WE_O       (LM32D_WE_O              )
  , .LM32D_CYC_O      (LM32D_CYC_O             )
  , .LM32D_STB_O      (LM32D_STB_O             )
  , .LM32D_SEL_O      (LM32D_SEL_O             )
  , .LM32D_BTE_O      (LM32D_BTE_O             )
  , .LM32D_LOCK_O     (LM32D_LOCK_O            )
  , .EXT1_DAT_O       (EXT1_DAT_O              )
  , .EXT1_ERR_I       (EXT1_ERR_I              )
  , .EXT1_ACK_I       (EXT1_ACK_I              )
  , .EXT1_DAT_I_bf_en (EXT1_DAT_I_bf_en        )
  );


//  LT2  ------------------------------------------------------

  //=======================================================
  //  write test char code
  //=======================================================
  reg  [15:0]  lt24_cnt ;
  always @ (posedge CLOCK_50 or negedge reset) begin
      if (~reset)
          lt24_cnt <= 0 ;
      else if (lt24_cnt > 80)
          lt24_cnt <= lt24_cnt ;
      else if (LT24_READYO)
//    else if (lt24_init_done)
          lt24_cnt <= lt24_cnt + 8 ;
  end

  wire [15:0]  base_x_from_cpu ;
  wire [15:0]  base_y_from_cpu ;
  wire [15:0]  color_to_char_gen ;
  wire [ 7:0]  char_code_to_char_gen ;

//assign color_to_char_gen     = COLOR_16BIT_BLUE ;
  assign color_to_char_gen     = COLOR_16BIT_RED ;
//assign color_to_char_gen     = COLOR_16BIT_WHITE ;
  assign base_x_from_cpu       = lt24_cnt ;
  assign base_y_from_cpu       = lt24_cnt ;

  assign char_code_to_char_gen = (lt24_cnt ==  8) ?`ASCII_a :
	                         (lt24_cnt == 16) ?`ASCII_b :
	                         (lt24_cnt == 24) ?`ASCII_c :
	                         (lt24_cnt == 32) ?`ASCII_d :
	                         (lt24_cnt == 40) ?`ASCII_e :
	                         (lt24_cnt == 48) ?`ASCII_f :
	                         (lt24_cnt == 56) ?`ASCII_g :
	                         (lt24_cnt == 64) ?`ASCII_h : `ASCII_i ;

  wire   wen_from_cpu          = (lt24_cnt ==  8) ? 1'b1 :
	                         (lt24_cnt == 16) ? 1'b1 :
	                         (lt24_cnt == 24) ? 1'b1 :
	                         (lt24_cnt == 32) ? 1'b1 :
	                         (lt24_cnt == 40) ? 1'b1 :
	                         (lt24_cnt == 48) ? 1'b1 :
	                         (lt24_cnt == 56) ? 1'b1 :
	                         (lt24_cnt == 64) ? 1'b1 : 1'b0 ;

 char_gen char_gen1 (
    .clk                 (CLOCK_50             )
//, .rstn                (reset                )
  , .rstn                (KEY[0]               )
  , .readyo              (LT24_READYO          )
  , .init_done           (lt24_init_done       )
  , .ffo                 (lt24_fifo_ffo        )  // MCU I/F
  , .wei                 (wen_from_cpu         )  // MCU I/F
  , .base_xi             (base_x_from_cpu      )  // MCU I/F
  , .base_yi             (base_y_from_cpu      )  // MCU I/F
  , .colori              (color_to_char_gen    )  // MCU I/F
  , .char_codei          (char_code_to_char_gen)  // MCU I/F
  , .LT24_ADC_BUSY       (LT24_ADC_BUSY        )
  , .LT24_ADC_CS_N       (LT24_ADC_CS_N        )
  , .LT24_ADC_DCLK       (LT24_ADC_DCLK        )
  , .LT24_ADC_DIN        (LT24_ADC_DIN         )
  , .LT24_ADC_DOUT       (LT24_ADC_DOUT        )
  , .LT24_ADC_PENIRQ_N   (LT24_ADC_PENIRQ_N    )
  , .LT24_CS_N           (LT24_CS_N            )  // ILITEK ILI9341 : CSX = low active
  , .LT24_D              (LT24_D               )
  , .LT24_LCD_ON         (LT24_LCD_ON          )
  , .LT24_RD_N           (LT24_RD_N            )  // ILITEK ILI9341 : RDX = read by rising edge
  , .LT24_RESET_N        (LT24_RESET_N         )  // ILITEK ILI9341 : reset = low active
  , .LT24_RS             (LT24_RS              )  // ILITEK ILI9341 : D/CX = command(L)/data(H) select
  , .LT24_WR_N           (LT24_WR_N            )  // ILITEK ILI9341 : WRX = write by rising edge
//, ,LT24_NC1            (1'b0                 )
//, ,LT24_NC2            (1'b0                 )
//, ,LT24_NC3            (1'b0                 )
//, ,LT24_NC4            (1'b0                 )
//, ,LT24_NC5            (1'b0                 )
//, ,LT24_NC6            (1'b0                 )
//, ,LT24_NC7            (1'b0                 )
//, .LT24_NC8            (1'b0                 )
  );


//  7SEG  ------------------------------------------------------
  always  @(led_cnt[19:16]) begin
      case (led_cnt[19:16])
          4'h0    : HEX0_REG  = SEG7_0   ;
          4'h1    : HEX0_REG  = SEG7_1   ;
          4'h2    : HEX0_REG  = SEG7_2   ;
          4'h3    : HEX0_REG  = SEG7_3   ;
          4'h4    : HEX0_REG  = SEG7_4   ;
          4'h5    : HEX0_REG  = SEG7_5   ;
          4'h6    : HEX0_REG  = SEG7_6   ;
          4'h7    : HEX0_REG  = SEG7_7   ;
          4'h8    : HEX0_REG  = SEG7_8   ;
          4'h9    : HEX0_REG  = SEG7_9   ;
          4'ha    : HEX0_REG  = SEG7_A   ;
          4'hb    : HEX0_REG  = SEG7_B   ;
          4'hc    : HEX0_REG  = SEG7_C   ;
          4'hd    : HEX0_REG  = SEG7_D   ;
          4'he    : HEX0_REG  = SEG7_E   ;
          4'hf    : HEX0_REG  = SEG7_F   ;
          default : HEX0_REG  = SEG7_OFF ;
      endcase
  end

  always  @(led_cnt[23:20]) begin
      case (led_cnt[23:20])
          4'h0    : HEX1_REG  = SEG7_0   ;
          4'h1    : HEX1_REG  = SEG7_1   ;
          4'h2    : HEX1_REG  = SEG7_2   ;
          4'h3    : HEX1_REG  = SEG7_3   ;
          4'h4    : HEX1_REG  = SEG7_4   ;
          4'h5    : HEX1_REG  = SEG7_5   ;
          4'h6    : HEX1_REG  = SEG7_6   ;
          4'h7    : HEX1_REG  = SEG7_7   ;
          4'h8    : HEX1_REG  = SEG7_8   ;
          4'h9    : HEX1_REG  = SEG7_9   ;
          4'ha    : HEX1_REG  = SEG7_A   ;
          4'hb    : HEX1_REG  = SEG7_B   ;
          4'hc    : HEX1_REG  = SEG7_C   ;
          4'hd    : HEX1_REG  = SEG7_D   ;
          4'he    : HEX1_REG  = SEG7_E   ;
          4'hf    : HEX1_REG  = SEG7_F   ;
          default : HEX1_REG  = SEG7_OFF ;
      endcase
  end

  always  @(led_cnt[27:24]) begin
      case (led_cnt[27:24])
          4'h0    : HEX2_REG  = SEG7_0   ;
          4'h1    : HEX2_REG  = SEG7_1   ;
          4'h2    : HEX2_REG  = SEG7_2   ;
          4'h3    : HEX2_REG  = SEG7_3   ;
          4'h4    : HEX2_REG  = SEG7_4   ;
          4'h5    : HEX2_REG  = SEG7_5   ;
          4'h6    : HEX2_REG  = SEG7_6   ;
          4'h7    : HEX2_REG  = SEG7_7   ;
          4'h8    : HEX2_REG  = SEG7_8   ;
          4'h9    : HEX2_REG  = SEG7_9   ;
          4'ha    : HEX2_REG  = SEG7_A   ;
          4'hb    : HEX2_REG  = SEG7_B   ;
          4'hc    : HEX2_REG  = SEG7_C   ;
          4'hd    : HEX2_REG  = SEG7_D   ;
          4'he    : HEX2_REG  = SEG7_E   ;
          4'hf    : HEX2_REG  = SEG7_F   ;
          default : HEX2_REG  = SEG7_OFF ;
      endcase
  end

  always  @(led_cnt[31:28]) begin
      case (led_cnt[31:28])
          4'h0    : HEX3_REG  = SEG7_0   ;
          4'h1    : HEX3_REG  = SEG7_1   ;
          4'h2    : HEX3_REG  = SEG7_2   ;
          4'h3    : HEX3_REG  = SEG7_3   ;
          4'h4    : HEX3_REG  = SEG7_4   ;
          4'h5    : HEX3_REG  = SEG7_5   ;
          4'h6    : HEX3_REG  = SEG7_6   ;
          4'h7    : HEX3_REG  = SEG7_7   ;
          4'h8    : HEX3_REG  = SEG7_8   ;
          4'h9    : HEX3_REG  = SEG7_9   ;
          4'ha    : HEX3_REG  = SEG7_A   ;
          4'hb    : HEX3_REG  = SEG7_B   ;
          4'hc    : HEX3_REG  = SEG7_C   ;
          4'hd    : HEX3_REG  = SEG7_D   ;
          4'he    : HEX3_REG  = SEG7_E   ;
          4'hf    : HEX3_REG  = SEG7_F   ;
          default : HEX3_REG  = SEG7_OFF ;
      endcase
  end

  always  @(led_cnt[19:16]) begin
      case (led_cnt[19:16])
          4'h0    : HEX4_REG  = SEG7_0   ;
          4'h1    : HEX4_REG  = SEG7_1   ;
          4'h2    : HEX4_REG  = SEG7_2   ;
          4'h3    : HEX4_REG  = SEG7_3   ;
          4'h4    : HEX4_REG  = SEG7_4   ;
          4'h5    : HEX4_REG  = SEG7_5   ;
          4'h6    : HEX4_REG  = SEG7_6   ;
          4'h7    : HEX4_REG  = SEG7_7   ;
          4'h8    : HEX4_REG  = SEG7_8   ;
          4'h9    : HEX4_REG  = SEG7_9   ;
          4'ha    : HEX4_REG  = SEG7_A   ;
          4'hb    : HEX4_REG  = SEG7_B   ;
          4'hc    : HEX4_REG  = SEG7_C   ;
          4'hd    : HEX4_REG  = SEG7_D   ;
          4'he    : HEX4_REG  = SEG7_E   ;
          4'hf    : HEX4_REG  = SEG7_F   ;
          default : HEX4_REG  = SEG7_OFF ;
      endcase
  end

  always  @(led_cnt[23:20]) begin
      case (led_cnt[23:20])
          4'h0    : HEX5_REG  = SEG7_0   ;
          4'h1    : HEX5_REG  = SEG7_1   ;
          4'h2    : HEX5_REG  = SEG7_2   ;
          4'h3    : HEX5_REG  = SEG7_3   ;
          4'h4    : HEX5_REG  = SEG7_4   ;
          4'h5    : HEX5_REG  = SEG7_5   ;
          4'h6    : HEX5_REG  = SEG7_6   ;
          4'h7    : HEX5_REG  = SEG7_7   ;
          4'h8    : HEX5_REG  = SEG7_8   ;
          4'h9    : HEX5_REG  = SEG7_9   ;
          4'ha    : HEX5_REG  = SEG7_A   ;
          4'hb    : HEX5_REG  = SEG7_B   ;
          4'hc    : HEX5_REG  = SEG7_C   ;
          4'hd    : HEX5_REG  = SEG7_D   ;
          4'he    : HEX5_REG  = SEG7_E   ;
          4'hf    : HEX5_REG  = SEG7_F   ;
          default : HEX5_REG  = SEG7_OFF ;
      endcase
  end

  always  @(led_cnt[27:24]) begin
      case (led_cnt[27:24])
          4'h0    : HEX6_REG  = SEG7_0   ;
          4'h1    : HEX6_REG  = SEG7_1   ;
          4'h2    : HEX6_REG  = SEG7_2   ;
          4'h3    : HEX6_REG  = SEG7_3   ;
          4'h4    : HEX6_REG  = SEG7_4   ;
          4'h5    : HEX6_REG  = SEG7_5   ;
          4'h6    : HEX6_REG  = SEG7_6   ;
          4'h7    : HEX6_REG  = SEG7_7   ;
          4'h8    : HEX6_REG  = SEG7_8   ;
          4'h9    : HEX6_REG  = SEG7_9   ;
          4'ha    : HEX6_REG  = SEG7_A   ;
          4'hb    : HEX6_REG  = SEG7_B   ;
          4'hc    : HEX6_REG  = SEG7_C   ;
          4'hd    : HEX6_REG  = SEG7_D   ;
          4'he    : HEX6_REG  = SEG7_E   ;
          4'hf    : HEX6_REG  = SEG7_F   ;
          default : HEX6_REG  = SEG7_OFF ;
      endcase
  end

  always  @(led_cnt[31:28]) begin
      case (led_cnt[31:28])
          4'h0    : HEX7_REG  = SEG7_0   ;
          4'h1    : HEX7_REG  = SEG7_1   ;
          4'h2    : HEX7_REG  = SEG7_2   ;
          4'h3    : HEX7_REG  = SEG7_3   ;
          4'h4    : HEX7_REG  = SEG7_4   ;
          4'h5    : HEX7_REG  = SEG7_5   ;
          4'h6    : HEX7_REG  = SEG7_6   ;
          4'h7    : HEX7_REG  = SEG7_7   ;
          4'h8    : HEX7_REG  = SEG7_8   ;
          4'h9    : HEX7_REG  = SEG7_9   ;
          4'ha    : HEX7_REG  = SEG7_A   ;
          4'hb    : HEX7_REG  = SEG7_B   ;
          4'hc    : HEX7_REG  = SEG7_C   ;
          4'hd    : HEX7_REG  = SEG7_D   ;
          4'he    : HEX7_REG  = SEG7_E   ;
          4'hf    : HEX7_REG  = SEG7_F   ;
          default : HEX7_REG  = SEG7_OFF ;
      endcase
  end

  assign  HEX0 = HEX0_REG ;
  assign  HEX1 = HEX1_REG ;
  assign  HEX2 = HEX2_REG ;
  assign  HEX3 = HEX3_REG ;
  assign  HEX4 = HEX4_REG ;
  assign  HEX5 = HEX5_REG ;
  assign  HEX6 = HEX6_REG ;
  assign  HEX7 = HEX7_REG ;


//  LED  ------------------------------------------------------
  assign LEDG[8] = reset ;

  assign LEDR[17] = !load_store_unit_ram_out_and ;
  assign LEDR[16] = led_cnt[31] ;
  assign LEDR[15] = led_cnt[30] ;
  assign LEDR[14] = led_cnt[29] ;
  assign LEDR[13] = led_cnt[28] ;  // 50MHz * [25] = blink per 1s 2017.12.30
  assign LEDR[12] = led_cnt[27] ;  // 50MHz * [25] = blink per 1s 2017.12.30
  assign LEDR[11] = led_cnt[26] ;  // 50MHz * [25] = blink per 1s 2017.12.30
  assign LEDR[10] = led_cnt[25] ;  // 50MHz * [25] = blink per 1s 2017.12.30
  assign LEDR[9]  = led_cnt[24] ;  // 50MHz * [25] = blink per 1s 2017.12.30
  assign LEDR[8]  = led_cnt[23] ;  // 50MHz * [25] = blink per 1s 2017.12.30
  assign LEDR[7]  = led_cnt[22] ;  // 50MHz * [25] = blink per 1s 2017.12.30
  assign LEDR[6]  = led_cnt[21] ;  // 50MHz * [25] = blink per 1s 2017.12.30
  assign LEDR[5]  = led_cnt[20] ;  // 50MHz * [25] = blink per 1s 2017.12.30
  assign LEDR[4]  = led_cnt[19] ;  // 50MHz * [25] = blink per 1s 2017.12.30
  assign LEDR[3]  = led_cnt[18] ;  // 50MHz * [25] = blink per 1s 2017.12.30
  assign LEDR[2]  = led_cnt[17] ;  // 50MHz * [25] = blink per 1s 2017.12.30
  assign LEDR[1]  = led_cnt[16] ;  // 50MHz * [25] = blink per 1s 2017.12.30
  assign LEDR[0]  = led_cnt[15] ;  // 50MHz * [25] = blink per 1s 2017.12.30

  reg [31:0] led_cnt ;
  always@(posedge CLOCK_50 or negedge reset ) begin
	if (~reset)
		led_cnt <= 0 ;
	else
		led_cnt <= led_cnt + 1 ;
  end

  reg [31:0] led_cnt2 ;
  always@(posedge CLOCK_50 or negedge reset ) begin
	if (~reset)
		led_cnt2 <= 0 ;
	else
		led_cnt2 <= led_cnt2 + 1 ;
  end

endmodule
